// JUSTICE on Sol ‚Äî full_bot_final.bjs
// All-in-one Bots.Business script (deploy as a single script).
// NOTE: Keep your Bot token private and set it in the Bots.Business UI; do NOT embed it here.

//////////////////////
// CONFIG (already filled from your input)
//////////////////////

var ADMIN_IDS = [7561048693, 6450400107, 5470178483, 5713536787]; // admin numeric IDs
var ADMIN_GROUP_ID = -1003140359659; // admin group id
var BROADCAST_CHANNEL = "@livetransactiontrack"; // logging / review channel

// VERIFY channels (5). If an entry starts with "http", it will be shown as link but NOT membership-checked.
var VERIFY_CHANNELS = [
  "@livetransactiontrack",
  "@Justiceonsolana1",
  "@justiceonsolana",
  "@ComeOEXOfficial",
  "https://x.com/onchain_justice?t=6QUIvpSUESeDRUGwDXoZSQ&s=09"
];

var BOT_USERNAME = ( "@justiceonsolana333bot".replace(/^@/,'') ); // bot username without @

var ABOUT_US_URL = "https://t.me/justiceonsolana/5";
var SUPPORT_URL = "https://t.me/justiceonsolbot";
var STATS_URL = null; // not used as URL; Stats is an internal view

// Review channels (you used the same channel for both)
var TASK_REVIEW_CHANNEL = "@livetransactiontrack";
var WITHDRAW_REVIEW_CHANNEL = "@livetransactiontrack";

// Rewards & system defaults
var REFERRAL_REWARD = 20;      // units to give to referrer on successful verification
var DEFAULT_BONUS_AMOUNT = 3;  // bonus amount
var CURRENCY_SYMBOL = "‚öñÔ∏è";
var BOT_NAME = "JUSTICE on Sol";
var BOT_LOGO = ""; // not used

//////////////////////
// Utilities & storage (uses Bot properties)
//////////////////////

function loadDB() {
  var raw = Bot.getProperty("__users_store__");
  if (!raw) return {};
  try { return JSON.parse(raw); } catch (e) { return {}; }
}
function saveDB(db) {
  Bot.setProperty("__users_store__", JSON.stringify(db));
}
function ensureUser(uid) {
  var db = loadDB();
  if (!db[uid]) {
    db[uid] = {
      id: uid,
      balance: 0,
      wallet: "",
      referrals: [],
      referredBy: null,
      verified: false
    };
    saveDB(db);
  }
  return db[uid];
}
function updateUser(uid, obj) {
  var db = loadDB(); db[uid] = obj; saveDB(db);
}
function getUser(uid) { var db = loadDB(); return db[uid] || null; }
function isAdminId(id) { return ADMIN_IDS.indexOf(Number(id)) !== -1; }

if (Bot.getProperty("REFERRAL_REWARD") === undefined) Bot.setProperty("REFERRAL_REWARD", REFERRAL_REWARD);
if (Bot.getProperty("BONUS_AMOUNT") === undefined) Bot.setProperty("BONUS_AMOUNT", DEFAULT_BONUS_AMOUNT);
if (Bot.getProperty("WITHDRAWAL_OPEN") === undefined) Bot.setProperty("WITHDRAWAL_OPEN", false);
if (Bot.getProperty("TASKS_SUBMITTED") === undefined) Bot.setProperty("TASKS_SUBMITTED", 0);

function logAdmin(text) {
  try { Api.sendMessage({ chat_id: BROADCAST_CHANNEL, text: text }); } catch (e) {}
}
function sendEphemeralWarning(chat_id, text) {
  try {
    var m = Api.sendMessage({ chat_id: chat_id, text: text });
    Bot.sleep(2000);
    Api.deleteMessage({ chat_id: chat_id, message_id: m.message_id });
  } catch (e) {}
}

//////////////////////
// START -> welcome -> Continue (reply keyboard)
//////////////////////

onCommand("start", function(){
  var user = GetUser();
  var uid = user.telegramid;
  ensureUser(uid);

  // referral param handling (Bots.Business provides request.data.start sometimes)
  var startParam = (request && request.data && request.data.start) ? request.data.start : null;
  if (startParam && startParam != String(uid)) {
    var me = ensureUser(uid);
    if (!me.referredBy) { me.referredBy = startParam; updateUser(uid, me); }
  }

  var welcomeText = "üëã Welcome to JUSTICE on Sol, " + (user.first_name || "") + "!\n\nJUSTICE helps fight fraud and unfairness in crypto. Join our communities to continue.";
  var kb = { keyboard: [["‚û°Ô∏è Continue"]], resize_keyboard: true, one_time_keyboard: true };
  Api.sendMessage({ chat_id: uid, text: welcomeText, reply_markup: JSON.stringify(kb) });
});

//////////////////////
// When user presses Continue (reply keyboard)
//////////////////////

on("message", function(){
  if (!request.text) return;

  var text = request.text.trim();
  var chat_id = request.chat.id;

  // Continue to verification
  if (text === "‚û°Ô∏è Continue") {
    // build inline keyboard 1-2-2 and Verify button
    var ch = VERIFY_CHANNELS;
    var ik = [
      [ { text: ch[0], url: ch[0].startsWith("http") ? ch[0] : "https://t.me/" + ch[0].replace(/^@/,'') } ],
      [
        { text: ch[1], url: ch[1].startsWith("http") ? ch[1] : "https://t.me/" + ch[1].replace(/^@/,'') },
        { text: ch[2], url: ch[2].startsWith("http") ? ch[2] : "https://t.me/" + ch[2].replace(/^@/,'') }
      ],
      [
        { text: ch[3], url: ch[3].startsWith("http") ? ch[3] : "https://t.me/" + ch[3].replace(/^@/,'') },
        { text: ch[4], url: ch[4].startsWith("http") ? ch[4] : "https://t.me/" + ch[4].replace(/^@/,'') }
      ],
      [ { text: "‚úÖ Verify", callback_data: "verify_now" } ]
    ];
    Api.sendMessage({ chat_id: chat_id, text: "üì¢ Please join all the channels below, then press Verify.", reply_markup: JSON.stringify({ inline_keyboard: ik }) });
    return;
  }

  // MENU reply keyboard navigation
  if (text === "üéØ Task") { Bot.runCommand("task"); return; }
  if (text === "üéÅ Bonus") { Bot.runCommand("bonus"); return; }
  if (text === "üíº Trade") { Bot.runCommand("trade"); return; }
  if (text === "üí≥ Set Wallet") { Bot.runCommand("setwallet"); return; }
  if (text === "üë• Referral") { Bot.runCommand("referral"); return; }
  if (text === "üí∞ Balance") { Bot.runCommand("balance"); return; }
  if (text === "‚ÑπÔ∏è About Us") {
    Api.sendMessage({ chat_id: chat_id, text: "About Us", reply_markup: JSON.stringify({ inline_keyboard: [[ { text: "Open About Us", url: ABOUT_US_URL } ]] }) });
    return;
  }
  if (text === "üí¨ Support") {
    // support username -> t.me link
    var supportLink = SUPPORT_URL.startsWith("http") ? SUPPORT_URL : "https://t.me/" + SUPPORT_URL.replace(/^@/,'');
    Api.sendMessage({ chat_id: chat_id, text: "Support", reply_markup: JSON.stringify({ inline_keyboard: [[ { text: "Open Support", url: supportLink } ]] }) });
    return;
  }
  if (text === "üìä Stats") { Bot.runCommand("stats"); return; }

  // Wallet input if awaited
  var awaiting = Bot.getProperty("awaiting_wallet_" + request.from.id);
  if (awaiting) {
    var addr = request.text.trim();
    var u = ensureUser(request.from.id);
    u.wallet = addr; updateUser(request.from.id, u);
    Bot.removeProperty("awaiting_wallet_" + request.from.id);
    Api.sendMessage({ chat_id: request.chat.id, text: "‚úÖ Wallet saved: " + addr });
    return;
  }

  // otherwise ignore or handle other free-text flows
});

//////////////////////
// CallbackQuery handler (verify + misc)
//////////////////////

Bot.onCallbackQuery(function(){
  var data = request.data;
  var from = request.from;
  if (!data) return;

  // Verification: skip non-telegram verify entries (those starting with http cannot be checked)
  if (data === "verify_now") {
    var uid = from.id;
    var missing = [];
    for (var i=0;i<VERIFY_CHANNELS.length;i++){
      var ch = VERIFY_CHANNELS[i];
      if (ch.startsWith("http")) {
        // cannot check membership for non-telegram link -> skip check
        continue;
      }
      try {
        var status = Bot.getChatMember(ch, uid);
        if (!status || (status.status !== 'member' && status.status !== 'administrator' && status.status !== 'creator')) {
          missing.push(ch);
        }
      } catch (e) {
        missing.push(ch);
      }
    }
    if (missing.length > 0) {
      Api.answerCallbackQuery({ callback_query_id: request.id, text: "Please join all required Telegram channels and try again.", show_alert: true });
      return;
    }

    var user = ensureUser(uid);
    if (!user.verified) {
      user.verified = true;
      if (user.referredBy) {
        var ref = ensureUser(user.referredBy);
        var reward = Number(Bot.getProperty("REFERRAL_REWARD") || REFERRAL_REWARD);
        ref.balance = Number(ref.balance || 0) + reward;
        ref.referrals = ref.referrals || [];
        ref.referrals.push(uid);
        updateUser(user.referredBy, ref);
        try { Api.sendMessage({ chat_id: user.referredBy, text: "üéâ You earned " + reward + " for referring a verified user!" }); } catch(e) {}
      }
      updateUser(uid, user);
    }

    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Verification successful!" });
    try { Bot.runCommand("menu"); } catch(e) { Api.sendMessage({ chat_id: uid, text: "‚úÖ Verified ‚Äî use /menu to open the menu." }); }
    return;
  }

  // Admin action callback patterns:
  // task_confirm:UID
  // task_reject:UID
  // withdraw_confirm:UID:AMOUNT
  // withdraw_reject:UID:AMOUNT

  if (data.indexOf("task_confirm:") === 0) {
    var parts = data.split(":"); var target = parts[1];
    handleAdminTaskConfirm(request.from.id, target);
    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Task approved." });
    return;
  }
  if (data.indexOf("task_reject:") === 0) {
    var parts = data.split(":"); var target = parts[1];
    handleAdminTaskReject(request.from.id, target);
    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Task rejected." });
    return;
  }
  if (data.indexOf("withdraw_confirm:") === 0) {
    var parts = data.split(":"); var target = parts[1]; var amount = Number(parts[2]);
    handleAdminWithdrawConfirm(request.from.id, target, amount);
    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Withdrawal approved." });
    return;
  }
  if (data.indexOf("withdraw_reject:") === 0) {
    var parts = data.split(":"); var target = parts[1]; handleAdminWithdrawReject(request.from.id, target);
    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Withdrawal rejected." });
    return;
  }

  // finish task submission callback
  if (data === "finish_task_submit") {
    finishTaskSubmit(request.from.id);
    Api.answerCallbackQuery({ callback_query_id: request.id, text: "Submission sent for review." });
    return;
  }
});

//////////////////////
// MENU command (reply keyboard)
//////////////////////

onCommand("menu", function(){
  var uid = request.from.id;
  var kb = {
    keyboard: [
      ["üéØ Task","üéÅ Bonus"],
      ["üíº Trade","üí≥ Set Wallet"],
      ["üë• Referral","üí∞ Balance"],
      ["‚ÑπÔ∏è About Us","üí¨ Support","üìä Stats"]
    ],
    resize_keyboard: true
  };
  Api.sendMessage({ chat_id: uid, text: "üè† Main Menu ‚Äî Choose an option:", reply_markup: JSON.stringify(kb) });
});

//////////////////////
// TASK flow (submit images + description)
//////////////////////

onCommand("task", function(){
  var uid = request.from.id;
  var txt = "üéØ Tasks:\n1) Share our channel\n2) Upload proof (images)\n\nPress Submit Proof to start.";
  var ik = { inline_keyboard: [[ { text: "Submit Proof", callback_data: "start_submit_task" } ]] };
  Api.sendMessage({ chat_id: uid, text: txt, reply_markup: JSON.stringify(ik) });
});

// start submission - set pending property
Bot.onCallbackQuery(function(){
  if (request.data === "start_submit_task") {
    var uid = request.from.id;
    Bot.setProperty("pending_task_" + uid, JSON.stringify({ files: [], text: "" }));
    Api.sendMessage({ chat_id: uid, text: "üì§ Send proof images and description. Press Done when finished.", reply_markup: JSON.stringify({ inline_keyboard:[ [ { text: "Done", callback_data: "finish_task_submit" } ] ] }) });
  }
});

// collect photos and text to pending submission
on("message", function() {
  var uid = request.from.id;
  var raw = Bot.getProperty("pending_task_" + uid);
  if (!raw) return;
  var pending = JSON.parse(raw);

  if (request.photo) {
    var sizes = request.photo;
    var last = sizes[sizes.length - 1];
    var fileId = last.file_id || last.file_id;
    pending.files.push(fileId);
    Bot.setProperty("pending_task_" + uid, JSON.stringify(pending));
    Api.sendMessage({ chat_id: uid, text: "‚úÖ Image received. Send more or press Done." });
    return;
  }
  if (request.text) {
    pending.text = (pending.text || "") + "\n" + request.text;
    Bot.setProperty("pending_task_" + uid, JSON.stringify(pending));
    Api.sendMessage({ chat_id: uid, text: "‚úÖ Description saved. Send more or press Done." });
    return;
  }
});

// finalize and forward to review with admin buttons
function finishTaskSubmit(uid) {
  var raw = Bot.getProperty("pending_task_" + uid);
  if (!raw) { Api.sendMessage({ chat_id: uid, text: "No pending submission. Use /task to start." }); return; }
  var pending = JSON.parse(raw);
  var msg = "üìù New Task Submission\nUser ID: " + uid + "\n\nDescription:\n" + (pending.text || "(no description)");

  // admin inline buttons with callback data
  var ik = { inline_keyboard: [ [ { text: "‚úÖ Confirm", callback_data: "task_confirm:" + uid }, { text: "‚ùå Reject", callback_data: "task_reject:" + uid } ] ] };

  Api.sendMessage({ chat_id: TASK_REVIEW_CHANNEL, text: msg });
  if (pending.files && pending.files.length > 0) {
    for (var i=0;i<pending.files.length;i++) {
      try { Api.sendPhoto({ chat_id: TASK_REVIEW_CHANNEL, photo: pending.files[i] }); } catch(e) {}
    }
  }
  Api.sendMessage({ chat_id: TASK_REVIEW_CHANNEL, text: "Admin review required:", reply_markup: JSON.stringify(ik) });

  // increment tasks submitted counter
  var count = Number(Bot.getProperty("TASKS_SUBMITTED") || 0) + 1;
  Bot.setProperty("TASKS_SUBMITTED", count);

  Api.sendMessage({ chat_id: uid, text: "‚úÖ Your submission has been sent for review." });
  Bot.removeProperty("pending_task_" + uid);
}

//////////////////////
// Admin handlers for task approve/reject (run in admin group)
//////////////////////

function handleAdminTaskConfirm(adminId, targetId) {
  // ensure admin-group context
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è This must be done in the admin group."); return; }
  if (!isAdminId(adminId)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  var reward = Number(Bot.getProperty("TASK_REWARD") || 0);
  var target = ensureUser(targetId);
  target.balance = Number(target.balance || 0) + reward;
  updateUser(targetId, target);
  try { Api.sendMessage({ chat_id: targetId, text: "‚úÖ Your task has been approved. Reward: " + reward }); } catch(e) {}
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Task approved for user: " + targetId });
  logAdmin("Task approved for user: " + targetId + " by admin: " + adminId);
}

function handleAdminTaskReject(adminId, targetId) {
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è This must be done in the admin group."); return; }
  if (!isAdminId(adminId)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  try { Api.sendMessage({ chat_id: targetId, text: "‚ùå Your task submission was rejected by admin." }); } catch(e) {}
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚ùå Task rejected for user: " + targetId });
  logAdmin("Task rejected for user: " + targetId + " by admin: " + adminId);
}

//////////////////////
// Bonus, Referral, Balance, Setwallet
//////////////////////

onCommand("bonus", function(){
  var uid = request.from.id; var u = ensureUser(uid);
  var bonus = Number(Bot.getProperty("BONUS_AMOUNT") || DEFAULT_BONUS_AMOUNT);
  u.balance = Number(u.balance || 0) + bonus;
  updateUser(uid, u);
  Api.sendMessage({ chat_id: uid, text: "üéÅ Bonus added: " + bonus + "\nCurrent balance: " + u.balance });
});

onCommand("referral", function(){
  var uid = request.from.id; var u = ensureUser(uid);
  var botname = Bot.getProperty("bot_username") || BOT_USERNAME;
  var link = "https://t.me/" + botname + "?start=" + uid;
  var earned = (u.referrals ? u.referrals.length * Number(Bot.getProperty("REFERRAL_REWARD") || REFERRAL_REWARD) : 0);
  Api.sendMessage({ chat_id: uid, text: "üë• Your referral link:\n" + link + "\nReferrals: " + (u.referrals ? u.referrals.length : 0) + "\nEarned: " + earned });
});

onCommand("balance", function(){ var uid = request.from.id; var u = ensureUser(uid); Api.sendMessage({ chat_id: uid, text: CURRENCY_SYMBOL + " Balance: " + (u.balance || 0) + "\nWallet: " + (u.wallet || "(not set)") }); });

onCommand("setwallet", function(){ var uid = request.from.id; Api.sendMessage({ chat_id: uid, text: "üîê Please send your wallet address now." }); Bot.setProperty("awaiting_wallet_" + uid, "1"); });

//////////////////////
// Withdrawals (request -> admin review)
//////////////////////

onCommand("withdraw", function(){
  var uid = request.from.id;
  if (!Bot.getProperty("WITHDRAWAL_OPEN")) { Api.sendMessage({ chat_id: uid, text: "‚ùå Withdrawals are currently closed." }); return; }
  Api.sendMessage({ chat_id: uid, text: "üí∏ To request withdrawal send: /requestwithdraw <amount>" });
});

onCommand(/requestwithdraw (.+)/, function(match){
  var amount = Number(match[1]); var uid = request.from.id; var u = ensureUser(uid);
  if (!Bot.getProperty("WITHDRAWAL_OPEN")) { Api.sendMessage({ chat_id: uid, text: "‚ùå Withdrawals are closed." }); return; }
  if (isNaN(amount) || amount <= 0 || amount > Number(u.balance || 0)) { Api.sendMessage({ chat_id: uid, text: "‚ùå Invalid amount or insufficient balance." }); return; }
  var ik = { inline_keyboard: [ [ { text: "‚úÖ Approve", callback_data: "withdraw_confirm:" + uid + ":" + amount }, { text: "‚ùå Reject", callback_data: "withdraw_reject:" + uid + ":" + amount } ] ] };
  Api.sendMessage({ chat_id: WITHDRAW_REVIEW_CHANNEL, text: "üí∏ Withdrawal request\nUser: " + uid + "\nAmount: " + amount + "\nWallet: " + (u.wallet || "(not set)"), reply_markup: JSON.stringify(ik) });
  Api.sendMessage({ chat_id: uid, text: "‚úÖ Your withdrawal request has been sent for review." });
});

function handleAdminWithdrawConfirm(adminId, targetId, amount) {
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è This must be done in the admin group."); return; }
  if (!isAdminId(adminId)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  var user = ensureUser(targetId);
  if (Number(user.balance || 0) < amount) { Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "Insufficient funds or user not found." }); return; }
  user.balance = Number(user.balance) - amount; updateUser(targetId, user);
  try { Api.sendMessage({ chat_id: targetId, text: "‚úÖ Your withdrawal of " + amount + " has been approved by admin." }); } catch(e) {}
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Withdrawal approved for user: " + targetId + " amount: " + amount });
  logAdmin("Withdrawal approved for user: " + targetId + " amount: " + amount + " by admin: " + adminId);
  // NOTE: Integrate real payout API here if needed.
}

function handleAdminWithdrawReject(adminId, targetId) {
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è This must be done in the admin group."); return; }
  if (!isAdminId(adminId)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  try { Api.sendMessage({ chat_id: targetId, text: "‚ùå Your withdrawal request was rejected by admin." }); } catch(e) {}
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚ùå Withdrawal rejected for user: " + targetId });
  logAdmin("Withdrawal rejected for user: " + targetId + " by admin: " + adminId);
}

//////////////////////
// Admin group-only text commands
//////////////////////

onCommand(/addbalance (.+) (.+)/, function(match){
  var tid = match[1], amt = Number(match[2]), uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run this inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  var u = ensureUser(tid); u.balance = Number(u.balance || 0) + amt; updateUser(tid, u);
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Added " + amt + " to user " + tid });
  logAdmin("addbalance " + tid + " " + amt + " by " + uid);
});

onCommand(/deductbalance (.+) (.+)/, function(match){
  var tid = match[1], amt = Number(match[2]), uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run this inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  var u = ensureUser(tid); u.balance = Number(u.balance || 0) - amt; if (u.balance < 0) u.balance = 0; updateUser(tid, u);
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Deducted " + amt + " from user " + tid });
  logAdmin("deductbalance " + tid + " " + amt + " by " + uid);
});

onCommand("openwithdrawal", function(){
  var uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  Bot.setProperty("WITHDRAWAL_OPEN", true);
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "üîì Withdrawals are now OPEN." });
  logAdmin("openwithdrawal by " + uid);
});

onCommand("closewithdrawal", function(){
  var uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  Bot.setProperty("WITHDRAWAL_OPEN", false);
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "üîí Withdrawals are now CLOSED." });
  logAdmin("closewithdrawal by " + uid);
});

onCommand(/broadcast (.+)/, function(match){
  var msg = match[1]; var uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  var db = loadDB(); var count = 0;
  for (var k in db) { try { Api.sendMessage({ chat_id: db[k].id, text: msg }); count++; } catch(e) {} }
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "üì£ Broadcast sent to " + count + " users." });
  logAdmin("broadcast by " + uid + " message: " + msg);
});

onCommand(/addtask (.+)/, function(match){
  var task = match[1]; var uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  Api.sendMessage({ chat_id: TASK_REVIEW_CHANNEL, text: "üéØ New Task: " + task });
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Task posted to review channel." });
  logAdmin("addtask by " + uid + " task: " + task);
});

onCommand(/updatereward (.+)/, function(match){
  var amount = Number(match[1]); var uid = request.from.id;
  if (request.chat.id !== ADMIN_GROUP_ID) { sendEphemeralWarning(request.chat.id, "‚ö†Ô∏è Run inside admin group only."); return; }
  if (!isAdminId(uid)) { sendEphemeralWarning(request.chat.id, "‚õî You are not authorized!"); return; }
  Bot.setProperty("REFERRAL_REWARD", amount);
  Api.sendMessage({ chat_id: ADMIN_GROUP_ID, text: "‚úÖ Referral reward updated to " + amount });
  logAdmin("updatereward to " + amount + " by " + uid);
});

//////////////////////
// Simple placeholders: about/support/trade
//////////////////////

onCommand("aboutus", function(){ Api.sendMessage({ chat_id: request.chat.id, text: "About Us ‚Äî open the About link in the menu." }); });
onCommand("support", function(){ Api.sendMessage({ chat_id: request.chat.id, text: "Support ‚Äî open the Support link in the menu." }); });
onCommand("trade", function(){ Api.sendMessage({ chat_id: request.chat.id, text: "üìä Trade Center: Signals and trade tools will show here." }); });

//////////////////////
// STATS command: totals and global progress
//////////////////////

onCommand("stats", function(){
  var uid = request.from.id;
  var db = loadDB();
  var totalUsers = 0, totalReferrals = 0, totalVerified = 0, tasksSubmitted = Number(Bot.getProperty("TASKS_SUBMITTED") || 0);
  for (var k in db) {
    totalUsers++;
    if (db[k].referrals) totalReferrals += db[k].referrals.length;
    if (db[k].verified) totalVerified++;
  }
  var progress = totalUsers === 0 ? 0 : Math.round((totalVerified / totalUsers) * 100);
  var txt = "üìä System Stats\n\nTotal users: " + totalUsers + "\nTasks submitted: " + tasksSubmitted + "\nTotal referrals: " + totalReferrals + "\nVerified users: " + totalVerified + "\nGlobal progress: " + progress + "%";
  Api.sendMessage({ chat_id: uid, text: txt });
});

//////////////////////
// Final notes
//////////////////////

// - Replace any remaining placeholder URL strings if you need different links.
// - For payouts, integrate your payment provider in handleAdminWithdrawConfirm.
// - Keep your bot token secure. On Bots.Business you set it in their UI, do NOT paste token into script.
// - Test thoroughly in a private environment before going public.

