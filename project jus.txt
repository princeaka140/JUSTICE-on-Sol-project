require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');

const token = process.env.BOT_TOKEN;
if (!token) {
  console.error('Error: BOT_TOKEN is not set in environment variables');
  process.exit(1);
}

const bot = new TelegramBot(token, { polling: true });

const ADMIN_IDS = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(Number) : [7561048693, 6450400107, 5470178483, 5713536787, 6221435595,  -1003140359659];
const ADMIN_GROUP_ID = Number(process.env.ADMIN_GROUP_ID || -1003140359659);
const BROADCAST_CHANNEL = process.env.BROADCAST_CHANNEL || "@livetransactiontrack";

const VERIFY_CHANNELS = [
  "@livetransactiontrack",
  "@Justiceonsolana1",
  "@justiceonsolana",
  "@ComeOEXOfficial",
  "https://x.com/onchain_justice?t=6QUIvpSUESeDRUGwDXoZSQ&s=09"
];

const CHANNELS_TO_VERIFY = [
  "@livetransactiontrack",
  "@Justiceonsolana1",
  "@justiceonsolana"
];

const BOT_USERNAME = process.env.BOT_USERNAME || "justiceonsolana333bot";
const ABOUT_US_URL = process.env.ABOUT_US_URL || "https://t.me/justiceonsolana/5";
const SUPPORT_URL = process.env.SUPPORT_URL || "https://t.me/justiceonsolbot";

const TASK_REVIEW_CHANNEL = process.env.TASK_REVIEW_CHANNEL || "@livetransactiontrack";
const WITHDRAW_REVIEW_CHANNEL = process.env.WITHDRAW_REVIEW_CHANNEL || "@livetransactiontrack";

let REFERRAL_REWARD = Number(process.env.REFERRAL_REWARD || 20);
let DEFAULT_BONUS_AMOUNT = Number(process.env.DEFAULT_BONUS_AMOUNT || 3);
const CURRENCY_SYMBOL = "âš–ï¸";
const BOT_NAME = "JUSTICE on Sol";

let usersDB = {};
let taskSubmissions = {};
let globalTasks = [];
let taskIdCounter = 1;
let botSettings = {
  referralReward: REFERRAL_REWARD,
  bonusAmount: DEFAULT_BONUS_AMOUNT,
  withdrawalOpen: false,
  tasksSubmitted: 0,
  tasksApproved: 0,
  tasksRejected: 0,
  taskReward: 0
};

let pendingTasks = {};
let awaitingWallet = {};

function ensureUser(uid, username = null, updateActivity = false) {
  if (!usersDB[uid]) {
    usersDB[uid] = {
      id: uid,
      username: username || "",
      balance: 0,
      wallet: "",
      referrals: [],
      referredBy: null,
      verified: false,
      registeredAt: Date.now(),
      lastSeen: Date.now(),
      messageCount: updateActivity ? 1 : 0,
      activityScore: 0,
      completedTasks: []
    };
    
    if (updateActivity) {
      const hoursSinceRegistration = (Date.now() - usersDB[uid].registeredAt) / (1000 * 60 * 60);
      if (hoursSinceRegistration > 0) {
        usersDB[uid].activityScore = usersDB[uid].messageCount / Math.max(hoursSinceRegistration, 0.01);
      }
    }
  } else {
    if (username) usersDB[uid].username = username;
    usersDB[uid].lastSeen = Date.now();
    
    if (updateActivity) {
      usersDB[uid].messageCount = (usersDB[uid].messageCount || 0) + 1;
      
      const hoursSinceRegistration = (Date.now() - usersDB[uid].registeredAt) / (1000 * 60 * 60);
      if (hoursSinceRegistration > 0) {
        usersDB[uid].activityScore = usersDB[uid].messageCount / Math.max(hoursSinceRegistration, 0.01);
      }
    }
  }
  return usersDB[uid];
}

function isAdminId(id) {
  return ADMIN_IDS.indexOf(Number(id)) !== -1;
}

async function getUserIdentifier(userId) {
  const user = usersDB[userId];
  if (user && user.username) {
    return `@${user.username}`;
  }
  return userId;
}

async function resolveUserInput(input) {
  if (input.startsWith('@')) {
    const username = input.substring(1).toLowerCase();
    for (const uid in usersDB) {
      if (usersDB[uid].username && usersDB[uid].username.toLowerCase() === username) {
        return usersDB[uid].id;
      }
    }
    return null;
  }
  return input;
}

function analyzeReferralPattern(userId) {
  const user = usersDB[userId];
  if (!user || !user.referrals || user.referrals.length === 0) {
    return { realRefs: 0, suspiciousRefs: 0, percentage: 100, score: "ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ" };
  }

  const referrals = user.referrals;
  let suspiciousCount = 0;
  const referralTimes = [];

  for (const refId of referrals) {
    const refUser = usersDB[refId];
    if (!refUser) continue;

    let suspiciousScore = 0;
    
    const accountAge = (Date.now() - refUser.registeredAt) / (1000 * 60 * 60);
    const accountAgeDays = accountAge / 24;
    
    if (accountAgeDays > 2 && refUser.messageCount < 3) suspiciousScore += 2;
    
    if (accountAgeDays > 1 && refUser.activityScore < 0.2) suspiciousScore += 1;
    
    if (accountAgeDays > 3 && !refUser.verified) suspiciousScore += 2;
    
    if (accountAgeDays > 7 && refUser.messageCount === 0) suspiciousScore += 2;

    referralTimes.push(refUser.registeredAt);
    
    if (suspiciousScore >= 4) {
      suspiciousCount++;
    }
  }

  referralTimes.sort((a, b) => a - b);
  let rapidSignups = 0;
  for (let i = 1; i < referralTimes.length; i++) {
    const timeDiff = (referralTimes[i] - referralTimes[i - 1]) / 1000;
    if (timeDiff < 30) {
      rapidSignups++;
    }
  }
  
  if (rapidSignups > 5) {
    suspiciousCount += Math.floor(rapidSignups / 3);
  }

  const realRefs = Math.max(0, referrals.length - suspiciousCount);
  const percentage = referrals.length > 0 ? (realRefs / referrals.length) * 100 : 100;
  const score = getStarRating(percentage);

  return {
    realRefs: realRefs,
    suspiciousRefs: suspiciousCount,
    percentage: percentage,
    score: score
  };
}

function analyzeSystemHealth() {
  const totalUsers = Object.keys(usersDB).length;
  if (totalUsers === 0) {
    return { realUsers: 0, suspiciousUsers: 0, percentage: 100, score: "ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ" };
  }

  let suspiciousUsers = 0;

  for (const uid in usersDB) {
    const user = usersDB[uid];
    let suspiciousScore = 0;

    const accountAge = (Date.now() - user.registeredAt) / (1000 * 60 * 60);
    const accountAgeDays = accountAge / 24;
    
    if (accountAgeDays > 2 && user.messageCount < 2) suspiciousScore += 2;
    
    if (accountAgeDays > 1 && user.activityScore < 0.1) suspiciousScore += 1;
    
    if (accountAgeDays > 3 && !user.verified) suspiciousScore += 2;
    
    if (accountAgeDays > 7 && user.messageCount === 0) suspiciousScore += 2;

    if (suspiciousScore >= 4) {
      suspiciousUsers++;
    }
  }

  const realUsers = totalUsers - suspiciousUsers;
  const percentage = totalUsers > 0 ? (realUsers / totalUsers) * 100 : 100;
  const score = getStarRating(percentage);

  return {
    realUsers: realUsers,
    suspiciousUsers: suspiciousUsers,
    percentage: percentage,
    score: score
  };
}

async function logAdmin(text) {
  try {
    await bot.sendMessage(BROADCAST_CHANNEL, text);
  } catch (e) {
    console.error('Error logging to admin:', e.message);
  }
}

async function sendEphemeralWarning(chatId, text, timeout = 2000) {
  try {
    const msg = await bot.sendMessage(chatId, text);
    setTimeout(async () => {
      try {
        await bot.deleteMessage(chatId, msg.message_id);
      } catch (e) {}
    }, timeout);
  } catch (e) {}
}

async function sendAutoDeleteMessage(chatId, text, timeout = 120000) {
  try {
    const msg = await bot.sendMessage(chatId, text);
    setTimeout(async () => {
      try {
        await bot.deleteMessage(chatId, msg.message_id);
      } catch (e) {}
    }, timeout);
    return msg;
  } catch (e) {
    return null;
  }
}

function getStarRating(percentage) {
  if (percentage >= 100) return "ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ";
  if (percentage >= 70) return "ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ";
  if (percentage >= 40) return "ğŸŒŸğŸŒŸğŸŒŸ";
  if (percentage >= 25) return "ğŸŒŸğŸŒŸ";
  if (percentage >= 10) return "ğŸŒŸ";
  if (percentage >= 8) return "âŒ";
  return "âŒâŒâŒâŒâŒ";
}

bot.onText(/\/start(?:\s+(.+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const username = msg.from.username || "";
  const startParam = match[1];

  ensureUser(userId, username);

  if (startParam && startParam != String(userId)) {
    const me = ensureUser(userId, username);
    if (!me.referredBy) {
      me.referredBy = startParam;
    }
  }

  const welcomeText = `ğŸ‘‹ Welcome to JUSTICE on Sol, ${msg.from.first_name || ''}!\n\nJUSTICE helps fight fraud and unfairness in crypto. Join our communities to continue.`;
  
  const keyboard = {
    keyboard: [["â¡ï¸ Continue"]],
    resize_keyboard: true,
    one_time_keyboard: true
  };

  await bot.sendMessage(chatId, welcomeText, { reply_markup: keyboard });
});

bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const username = msg.from.username || "";
  const text = msg.text;

  if (!text) return;

  ensureUser(userId, username, true);

  if (text === "â¡ï¸ Continue") {
    const ch = VERIFY_CHANNELS;
    const inlineKeyboard = [
      [{ text: ch[0], url: ch[0].startsWith("http") ? ch[0] : `https://t.me/${ch[0].replace(/^@/, '')}` }],
      [
        { text: ch[1], url: ch[1].startsWith("http") ? ch[1] : `https://t.me/${ch[1].replace(/^@/, '')}` },
        { text: ch[2], url: ch[2].startsWith("http") ? ch[2] : `https://t.me/${ch[2].replace(/^@/, '')}` }
      ],
      [
        { text: ch[3], url: ch[3].startsWith("http") ? ch[3] : `https://t.me/${ch[3].replace(/^@/, '')}` },
        { text: ch[4], url: ch[4].startsWith("http") ? ch[4] : `https://t.me/${ch[4].replace(/^@/, '')}` }
      ],
      [{ text: "âœ… Verify", callback_data: "verify_now" }]
    ];

    await bot.sendMessage(chatId, "ğŸ“¢ Please join all the channels below, then press Verify.", {
      reply_markup: { inline_keyboard: inlineKeyboard }
    });
    return;
  }

  if (text === "ğŸ¯ Task") {
    await handleTask(chatId);
    return;
  }
  if (text === "ğŸ Bonus") {
    await handleBonus(chatId, userId);
    return;
  }
  if (text === "ğŸ’¼ Trade") {
    await bot.sendMessage(chatId, "ğŸ’¼ Trade feature coming soon!");
    return;
  }
  if (text === "ğŸ’³ Set Wallet") {
    await handleSetWallet(chatId, userId);
    return;
  }
  if (text === "ğŸ‘¥ Referral") {
    await handleReferral(chatId, userId);
    return;
  }
  if (text === "ğŸ’° Balance") {
    await handleBalance(chatId, userId);
    return;
  }
  if (text === "ğŸ’¸ Withdrawal") {
    await handleWithdrawalMenu(chatId, userId);
    return;
  }
  if (text === "â„¹ï¸ About Us") {
    await bot.sendMessage(chatId, "About Us", {
      reply_markup: {
        inline_keyboard: [[{ text: "Open About Us", url: ABOUT_US_URL }]]
      }
    });
    return;
  }
  if (text === "ğŸ’¬ Support") {
    const supportLink = SUPPORT_URL.startsWith("http") ? SUPPORT_URL : `https://t.me/${SUPPORT_URL.replace(/^@/, '')}`;
    await bot.sendMessage(chatId, "Support", {
      reply_markup: {
        inline_keyboard: [[{ text: "Open Support", url: supportLink }]]
      }
    });
    return;
  }
  if (text === "ğŸ“Š Stats") {
    await handleStats(chatId);
    return;
  }

  if (awaitingWallet[userId]) {
    const addr = text.trim();
    const user = ensureUser(userId, username);
    user.wallet = addr;
    delete awaitingWallet[userId];
    await bot.sendMessage(chatId, `âœ… Wallet saved: ${addr}`);
    return;
  }

  if (pendingTasks[userId]) {
    if (msg.photo) {
      const photo = msg.photo[msg.photo.length - 1];
      pendingTasks[userId].files.push(photo.file_id);
      await bot.sendMessage(chatId, "âœ… Image received. Send more or press Done.");
      return;
    }
    if (text && text !== "Done") {
      pendingTasks[userId].text += "\n" + text;
      await bot.sendMessage(chatId, "âœ… Description saved. Send more or press Done.");
      return;
    }
  }
});

bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const userId = query.from.id;
  const data = query.data;

  if (data === "verify_now") {
    const missing = [];
    for (const ch of CHANNELS_TO_VERIFY) {
      try {
        const member = await bot.getChatMember(ch, userId);
        if (!['member', 'administrator', 'creator'].includes(member.status)) {
          missing.push(ch);
        }
      } catch (e) {
        missing.push(ch);
      }
    }

    if (missing.length > 0) {
      await bot.answerCallbackQuery(query.id, {
        text: "Please join all required Telegram channels and try again.",
        show_alert: true
      });
      return;
    }

    const user = ensureUser(userId, query.from.username);
    if (!user.verified) {
      user.verified = true;
      if (user.referredBy) {
        const ref = ensureUser(user.referredBy);
        const reward = botSettings.referralReward;
        ref.balance = Number(ref.balance || 0) + reward;
        ref.referrals = ref.referrals || [];
        ref.referrals.push(userId);
        try {
          await bot.sendMessage(user.referredBy, `ğŸ‰ You earned ${reward} for referring a verified user!`);
        } catch (e) {}
      }
    }

    await bot.answerCallbackQuery(query.id, { text: "Verification successful!" });
    await showMenu(chatId);
    return;
  }

  if (data === "start_submit_task") {
    pendingTasks[userId] = { files: [], text: "", userId: userId };
    await bot.sendMessage(chatId, "ğŸ“¤ Send proof images and description. Press Done when finished.", {
      reply_markup: {
        inline_keyboard: [[{ text: "Done", callback_data: "finish_task_submit" }]]
      }
    });
    await bot.answerCallbackQuery(query.id);
    return;
  }

  if (data === "finish_task_submit") {
    await finishTaskSubmit(userId, chatId);
    await bot.answerCallbackQuery(query.id, { text: "Submission sent for review." });
    return;
  }

  if (data.startsWith("task_confirm:")) {
    const targetId = data.split(":")[1];
    await handleAdminTaskConfirm(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Task approved." });
    return;
  }

  if (data.startsWith("task_reject:")) {
    const targetId = data.split(":")[1];
    await handleAdminTaskReject(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Task rejected." });
    return;
  }

  if (data.startsWith("withdraw_confirm:")) {
    const parts = data.split(":");
    const targetId = parts[1];
    const amount = Number(parts[2]);
    await handleAdminWithdrawConfirm(userId, targetId, amount, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Withdrawal approved." });
    return;
  }

  if (data.startsWith("withdraw_reject:")) {
    const parts = data.split(":");
    const targetId = parts[1];
    await handleAdminWithdrawReject(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Withdrawal rejected." });
    return;
  }
});

async function showMenu(chatId) {
  const keyboard = {
    keyboard: [
      ["ğŸ¯ Task", "ğŸ Bonus"],
      ["ğŸ’¼ Trade", "ğŸ’³ Set Wallet"],
      ["ğŸ‘¥ Referral", "ğŸ’° Balance"],
      ["ğŸ’¸ Withdrawal", "ğŸ“Š Stats"],
      ["â„¹ï¸ About Us", "ğŸ’¬ Support"]
    ],
    resize_keyboard: true
  };
  await bot.sendMessage(chatId, "ğŸ  Main Menu â€” Choose an option:", { reply_markup: keyboard });
}

async function handleTask(chatId) {
  const text = "ğŸ¯ Tasks:\n1) Share our channel\n2) Upload proof (images)\n\nPress Submit Proof to start.";
  const inlineKeyboard = {
    inline_keyboard: [[{ text: "Submit Proof", callback_data: "start_submit_task" }]]
  };
  await bot.sendMessage(chatId, text, { reply_markup: inlineKeyboard });
}

async function handleBonus(chatId, userId) {
  const user = ensureUser(userId);
  const bonus = botSettings.bonusAmount;
  user.balance = Number(user.balance || 0) + bonus;
  await bot.sendMessage(chatId, `ğŸ Bonus added: ${bonus}\nCurrent balance: ${user.balance}`);
}

async function handleSetWallet(chatId, userId) {
  await bot.sendMessage(chatId, "ğŸ” Please send your wallet address now.");
  awaitingWallet[userId] = true;
}

async function handleReferral(chatId, userId) {
  const user = ensureUser(userId);
  const link = `https://t.me/${BOT_USERNAME}?start=${userId}`;
  const earned = (user.referrals ? user.referrals.length * botSettings.referralReward : 0);
  await bot.sendMessage(chatId, `ğŸ‘¥ Your referral link:\n${link}\nReferrals: ${user.referrals ? user.referrals.length : 0}\nEarned: ${earned}`);
}

async function handleBalance(chatId, userId) {
  const user = ensureUser(userId);
  await bot.sendMessage(chatId, `${CURRENCY_SYMBOL} Balance: ${user.balance || 0}\nWallet: ${user.wallet || "(not set)"}`);
}

async function handleWithdrawalMenu(chatId, userId) {
  if (!botSettings.withdrawalOpen) {
    await bot.sendMessage(chatId, "âŒ Withdrawals are currently closed.");
    return;
  }
  await bot.sendMessage(chatId, "ğŸ’¸ To request withdrawal send:\n/requestwithdraw <amount>");
}

async function handleStats(chatId) {
  const totalUsers = Object.keys(usersDB).length;
  const verifiedUsers = Object.values(usersDB).filter(u => u.verified).length;
  const now = Date.now();
  const onlineUsers = Object.values(usersDB).filter(u => (now - u.lastSeen) < 300000).length;
  const offlineUsers = totalUsers - onlineUsers;
  
  const systemHealth = analyzeSystemHealth();
  const totalBalance = Object.values(usersDB).reduce((sum, u) => sum + (Number(u.balance) || 0), 0);
  
  const statsText = `ğŸ“Š System Statistics\n\n` +
    `Total Users: ${totalUsers}\n` +
    `Real Users: ${systemHealth.realUsers}\n` +
    `Suspicious Users: ${systemHealth.suspiciousUsers}\n` +
    `Users Online: ${onlineUsers}\n` +
    `Users Offline: ${offlineUsers}\n` +
    `Total Balance: ${totalBalance}\n\n` +
    `Progress Score: ${systemHealth.score}`;
  
  await bot.sendMessage(chatId, statsText);
}

async function finishTaskSubmit(userId, chatId) {
  const pending = pendingTasks[userId];
  if (!pending) {
    await bot.sendMessage(chatId, "No pending submission. Use ğŸ¯ Task to start.");
    return;
  }

  const userIdentifier = await getUserIdentifier(userId);
  const msg = `ğŸ“ New Task Submission\nUser: ${userIdentifier}\n\nDescription:\n${pending.text || "(no description)"}`;
  
  if (!taskSubmissions[userId]) {
    taskSubmissions[userId] = [];
  }
  
  const submission = {
    userId: userId,
    text: pending.text,
    files: pending.files,
    status: 'pending',
    timestamp: Date.now()
  };
  
  taskSubmissions[userId].push(submission);

  const inlineKeyboard = {
    inline_keyboard: [[
      { text: "âœ… Confirm", callback_data: `task_confirm:${userId}` },
      { text: "âŒ Reject", callback_data: `task_reject:${userId}` }
    ]]
  };

  await bot.sendMessage(TASK_REVIEW_CHANNEL, msg, { reply_markup: inlineKeyboard });
  
  if (pending.files && pending.files.length > 0) {
    for (const fileId of pending.files) {
      try {
        await bot.sendPhoto(TASK_REVIEW_CHANNEL, fileId);
      } catch (e) {}
    }
  }

  botSettings.tasksSubmitted++;
  await bot.sendMessage(chatId, "âœ… Your submission has been sent for review.");
  delete pendingTasks[userId];
}

async function handleAdminTaskConfirm(adminId, targetId, chatId) {
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const reward = botSettings.taskReward;
  const target = ensureUser(targetId);
  target.balance = Number(target.balance || 0) + reward;
  
  if (taskSubmissions[targetId] && taskSubmissions[targetId].length > 0) {
    const lastSubmission = taskSubmissions[targetId][taskSubmissions[targetId].length - 1];
    if (lastSubmission.status === 'pending') {
      lastSubmission.status = 'approved';
      botSettings.tasksApproved++;
    }
  }

  try {
    await bot.sendMessage(targetId, `âœ… Your task has been approved. Reward: ${reward}`);
  } catch (e) {}

  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(adminId);
  
  await logAdmin(`Task approved for user: ${userIdentifier} by admin: ${adminIdentifier}`);
}

async function handleAdminTaskReject(adminId, targetId, chatId) {
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }
  
  if (taskSubmissions[targetId] && taskSubmissions[targetId].length > 0) {
    const lastSubmission = taskSubmissions[targetId][taskSubmissions[targetId].length - 1];
    if (lastSubmission.status === 'pending') {
      lastSubmission.status = 'rejected';
      botSettings.tasksRejected++;
    }
  }

  try {
    await bot.sendMessage(targetId, "âŒ Your task submission was rejected by admin.");
  } catch (e) {}

  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(adminId);
  
  await logAdmin(`Task rejected for user: ${userIdentifier} by admin: ${adminIdentifier}`);
}

bot.onText(/\/requestwithdraw (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = Number(match[1]);
  const user = ensureUser(userId, msg.from.username);

  if (!botSettings.withdrawalOpen) {
    await bot.sendMessage(chatId, "âŒ Withdrawals are closed.");
    return;
  }

  if (isNaN(amount) || amount <= 0 || amount > Number(user.balance || 0)) {
    await bot.sendMessage(chatId, "âŒ Invalid amount or insufficient balance.");
    return;
  }

  const userIdentifier = await getUserIdentifier(userId);
  const inlineKeyboard = {
    inline_keyboard: [[
      { text: "âœ… Approve", callback_data: `withdraw_confirm:${userId}:${amount}` },
      { text: "âŒ Reject", callback_data: `withdraw_reject:${userId}:${amount}` }
    ]]
  };

  await bot.sendMessage(WITHDRAW_REVIEW_CHANNEL, 
    `ğŸ’¸ Withdrawal request\nUser: ${userIdentifier}\nAmount: ${amount}\nWallet: ${user.wallet || "(not set)"}`,
    { reply_markup: inlineKeyboard }
  );

  await bot.sendMessage(chatId, "âœ… Your withdrawal request has been sent for review.");
});

async function handleAdminWithdrawConfirm(adminId, targetId, amount, chatId) {
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const user = ensureUser(targetId);
  if (Number(user.balance || 0) < amount) {
    await sendEphemeralWarning(chatId, "Insufficient funds or user not found.");
    return;
  }

  user.balance = Number(user.balance) - amount;

  try {
    await bot.sendMessage(targetId, `âœ… Your withdrawal of ${amount} has been approved by admin.`);
  } catch (e) {}

  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(adminId);
  
  await logAdmin(`Withdrawal approved for user: ${userIdentifier} amount: ${amount} by admin: ${adminIdentifier}`);
}

async function handleAdminWithdrawReject(adminId, targetId, chatId) {
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  try {
    await bot.sendMessage(targetId, "âŒ Your withdrawal request was rejected by admin.");
  } catch (e) {}

  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(adminId);
  
  await logAdmin(`Withdrawal rejected for user: ${userIdentifier} by admin: ${adminIdentifier}`);
}

bot.onText(/\/addbalance (.+) (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];
  const amount = Number(match[2]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run this inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await sendAutoDeleteMessage(chatId, "âŒ User not found.");
    return;
  }

  const user = ensureUser(targetId);
  user.balance = Number(user.balance || 0) + amount;
  
  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `âœ… Added ${amount} to user ${userIdentifier}`);
  await logAdmin(`addbalance ${userIdentifier} ${amount} by ${adminIdentifier}`);
});

bot.onText(/\/deductbalance (.+) (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];
  const amount = Number(match[2]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run this inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await sendAutoDeleteMessage(chatId, "âŒ User not found.");
    return;
  }

  const user = ensureUser(targetId);
  user.balance = Number(user.balance || 0) - amount;
  if (user.balance < 0) user.balance = 0;
  
  const userIdentifier = await getUserIdentifier(targetId);
  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `âœ… Deducted ${amount} from user ${userIdentifier}`);
  await logAdmin(`deductbalance ${userIdentifier} ${amount} by ${adminIdentifier}`);
});

bot.onText(/\/openwithdrawal/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  botSettings.withdrawalOpen = true;
  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, "ğŸ”“ Withdrawals are now OPEN.");
  await logAdmin(`openwithdrawal by ${adminIdentifier}`);
});

bot.onText(/\/closewithdrawal/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  botSettings.withdrawalOpen = false;
  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, "ğŸ”’ Withdrawals are now CLOSED.");
  await logAdmin(`closewithdrawal by ${adminIdentifier}`);
});

bot.onText(/\/broadcast (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const message = match[1];

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  let count = 0;
  for (const uid in usersDB) {
    try {
      await bot.sendMessage(usersDB[uid].id, message);
      count++;
    } catch (e) {}
  }

  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `ğŸ“£ Broadcast sent to ${count} users.`);
  await logAdmin(`broadcast by ${adminIdentifier} message: ${message}`);
});

bot.onText(/\/addtask (.+) (\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const task = match[1];
  const reward = Number(match[2]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  botSettings.taskReward = reward;
  const adminIdentifier = await getUserIdentifier(userId);
  
  await bot.sendMessage(TASK_REVIEW_CHANNEL, `ğŸ¯ New Task: ${task}\nReward: ${reward}`);
  await sendAutoDeleteMessage(chatId, "âœ… Task posted to review channel.");
  await logAdmin(`addtask by ${adminIdentifier} task: ${task} reward: ${reward}`);
});

bot.onText(/\/updatereward (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = Number(match[1]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  botSettings.taskReward = amount;
  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `âœ… Task reward updated to ${amount}`);
  await logAdmin(`updatereward ${amount} by ${adminIdentifier}`);
});

bot.onText(/\/approvealltask/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  let count = 0;
  for (const uid in taskSubmissions) {
    const submissions = taskSubmissions[uid];
    for (const sub of submissions) {
      if (sub.status === 'pending') {
        sub.status = 'approved';
        const user = ensureUser(uid);
        user.balance = Number(user.balance || 0) + botSettings.taskReward;
        botSettings.tasksApproved++;
        count++;
        
        try {
          await bot.sendMessage(uid, `âœ… Your task has been approved. Reward: ${botSettings.taskReward}`);
        } catch (e) {}
      }
    }
  }

  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `âœ… Approved ${count} pending tasks.`);
  await logAdmin(`approvealltask by ${adminIdentifier} - ${count} tasks approved`);
});

bot.onText(/\/rejectalltask/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  let count = 0;
  for (const uid in taskSubmissions) {
    const submissions = taskSubmissions[uid];
    for (const sub of submissions) {
      if (sub.status === 'pending') {
        sub.status = 'rejected';
        botSettings.tasksRejected++;
        count++;
        
        try {
          await bot.sendMessage(uid, "âŒ Your task submission was rejected by admin.");
        } catch (e) {}
      }
    }
  }

  const adminIdentifier = await getUserIdentifier(userId);
  
  await sendAutoDeleteMessage(chatId, `âœ… Rejected ${count} pending tasks.`);
  await logAdmin(`rejectalltask by ${adminIdentifier} - ${count} tasks rejected`);
});

bot.onText(/\/approvetask (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await sendAutoDeleteMessage(chatId, "âŒ User not found.");
    return;
  }

  await handleAdminTaskConfirm(userId, targetId, chatId);
  
  const userIdentifier = await getUserIdentifier(targetId);
  await sendAutoDeleteMessage(chatId, `âœ… Task approved for ${userIdentifier}`);
});

bot.onText(/\/rejecttask (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await sendAutoDeleteMessage(chatId, "âŒ User not found.");
    return;
  }

  await handleAdminTaskReject(userId, targetId, chatId);
  
  const userIdentifier = await getUserIdentifier(targetId);
  await sendAutoDeleteMessage(chatId, `âœ… Task rejected for ${userIdentifier}`);
});

bot.onText(/\/taskstats/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "âš ï¸ Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const totalSubmissions = botSettings.tasksSubmitted;
  const approved = botSettings.tasksApproved;
  const rejected = botSettings.tasksRejected;
  const pending = totalSubmissions - approved - rejected;
  
  const approvalRate = totalSubmissions > 0 ? (approved / totalSubmissions) * 100 : 0;
  const score = getStarRating(approvalRate);
  
  const statsText = `ğŸ“Š Task Statistics\n\n` +
    `Total Submissions: ${totalSubmissions}\n` +
    `Pending: ${pending}\n` +
    `Rejected: ${rejected}\n` +
    `Approved: ${approved}\n\n` +
    `Score: ${score}`;
  
  await bot.sendMessage(chatId, statsText);
});

bot.onText(/\/balance (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];

  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await bot.sendMessage(chatId, "âŒ User not found.");
    return;
  }

  const user = ensureUser(targetId);
  const userIdentifier = await getUserIdentifier(targetId);
  
  await bot.sendMessage(chatId, 
    `${CURRENCY_SYMBOL} Balance for ${userIdentifier}:\n` +
    `Balance: ${user.balance || 0}\n` +
    `Wallet: ${user.wallet || "(not set)"}`
  );
});

bot.onText(/\/referral (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetInput = match[1];

  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "â›” You are not authorized!");
    return;
  }

  const targetId = await resolveUserInput(targetInput);
  if (!targetId) {
    await bot.sendMessage(chatId, "âŒ User not found.");
    return;
  }

  const analysis = analyzeReferralPattern(targetId);
  const userIdentifier = await getUserIdentifier(targetId);
  
  const refText = `ğŸ‘¥ Referral Analysis for ${userIdentifier}\n\n` +
    `Total Referrals: ${(usersDB[targetId].referrals || []).length}\n` +
    `Real Refs: ${analysis.realRefs}\n` +
    `Suspicious Refs: ${analysis.suspiciousRefs}\n\n` +
    `Score: ${analysis.score}`;
  
  await bot.sendMessage(chatId, refText);
});

bot.onText(/\/stats/, async (msg) => {
  const chatId = msg.chat.id;
  await handleStats(chatId);
});

bot.onText(/\/menu/, async (msg) => {
  await showMenu(msg.chat.id);
});

console.log('Bot is running...');
