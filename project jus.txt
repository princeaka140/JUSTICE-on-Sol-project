require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');

const token = process.env.BOT_TOKEN;
if (!token) {
  console.error('Error: BOT_TOKEN is not set in environment variables');
  process.exit(1);
}

const bot = new TelegramBot(token, { polling: true });

const ADMIN_IDS = process.env.ADMIN_IDS ? process.env.ADMIN_IDS.split(',').map(Number) : [7561048693, 6450400107, 5470178483, 5713536787, -1003140359659];
const ADMIN_GROUP_ID = Number(process.env.ADMIN_GROUP_ID || -1003140359659);
const BROADCAST_CHANNEL = process.env.BROADCAST_CHANNEL || "@livetransactiontrack";

const VERIFY_CHANNELS = [
  "@livetransactiontrack",
  "@Justiceonsolana1",
  "@justiceonsolana",
  "@ComeOEXOfficial",
  "https://x.com/onchain_justice?t=6QUIvpSUESeDRUGwDXoZSQ&s=09"
];

const CHANNELS_TO_VERIFY = [
  "@livetransactiontrack",
  "@Justiceonsolana1",
  "@justiceonsolana"
];

const BOT_USERNAME = process.env.BOT_USERNAME || "justiceonsolana333bot";
const ABOUT_US_URL = process.env.ABOUT_US_URL || "https://t.me/justiceonsolana/5";
const SUPPORT_URL = process.env.SUPPORT_URL || "https://t.me/justiceonsolbot";

const TASK_REVIEW_CHANNEL = process.env.TASK_REVIEW_CHANNEL || "@livetransactiontrack";
const WITHDRAW_REVIEW_CHANNEL = process.env.WITHDRAW_REVIEW_CHANNEL || "@livetransactiontrack";

let REFERRAL_REWARD = Number(process.env.REFERRAL_REWARD || 20);
let DEFAULT_BONUS_AMOUNT = Number(process.env.DEFAULT_BONUS_AMOUNT || 3);
const CURRENCY_SYMBOL = "‚öñÔ∏è";
const BOT_NAME = "JUSTICE on Sol";

let usersDB = {};
let botSettings = {
  referralReward: REFERRAL_REWARD,
  bonusAmount: DEFAULT_BONUS_AMOUNT,
  withdrawalOpen: false,
  tasksSubmitted: 0,
  taskReward: 0
};

let pendingTasks = {};
let awaitingWallet = {};

function ensureUser(uid) {
  if (!usersDB[uid]) {
    usersDB[uid] = {
      id: uid,
      balance: 0,
      wallet: "",
      referrals: [],
      referredBy: null,
      verified: false
    };
  }
  return usersDB[uid];
}

function isAdminId(id) {
  return ADMIN_IDS.indexOf(Number(id)) !== -1;
}

async function logAdmin(text) {
  try {
    await bot.sendMessage(BROADCAST_CHANNEL, text);
  } catch (e) {
    console.error('Error logging to admin:', e.message);
  }
}

async function sendEphemeralWarning(chatId, text) {
  try {
    const msg = await bot.sendMessage(chatId, text);
    setTimeout(async () => {
      try {
        await bot.deleteMessage(chatId, msg.message_id);
      } catch (e) {}
    }, 2000);
  } catch (e) {}
}

bot.onText(/\/start(?:\s+(.+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const startParam = match[1];

  ensureUser(userId);

  if (startParam && startParam != String(userId)) {
    const me = ensureUser(userId);
    if (!me.referredBy) {
      me.referredBy = startParam;
    }
  }

  const welcomeText = `üëã Welcome to JUSTICE on Sol, ${msg.from.first_name || ''}!\n\nJUSTICE helps fight fraud and unfairness in crypto. Join our communities to continue.`;
  
  const keyboard = {
    keyboard: [["‚û°Ô∏è Continue"]],
    resize_keyboard: true,
    one_time_keyboard: true
  };

  await bot.sendMessage(chatId, welcomeText, { reply_markup: keyboard });
});

bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const text = msg.text;

  if (!text) return;

  if (text === "‚û°Ô∏è Continue") {
    const ch = VERIFY_CHANNELS;
    const inlineKeyboard = [
      [{ text: ch[0], url: ch[0].startsWith("http") ? ch[0] : `https://t.me/${ch[0].replace(/^@/, '')}` }],
      [
        { text: ch[1], url: ch[1].startsWith("http") ? ch[1] : `https://t.me/${ch[1].replace(/^@/, '')}` },
        { text: ch[2], url: ch[2].startsWith("http") ? ch[2] : `https://t.me/${ch[2].replace(/^@/, '')}` }
      ],
      [
        { text: ch[3], url: ch[3].startsWith("http") ? ch[3] : `https://t.me/${ch[3].replace(/^@/, '')}` },
        { text: ch[4], url: ch[4].startsWith("http") ? ch[4] : `https://t.me/${ch[4].replace(/^@/, '')}` }
      ],
      [{ text: "‚úÖ Verify", callback_data: "verify_now" }]
    ];

    await bot.sendMessage(chatId, "üì¢ Please join all the channels below, then press Verify.", {
      reply_markup: { inline_keyboard: inlineKeyboard }
    });
    return;
  }

  if (text === "üéØ Task") {
    await handleTask(chatId);
    return;
  }
  if (text === "üéÅ Bonus") {
    await handleBonus(chatId, userId);
    return;
  }
  if (text === "üíº Trade") {
    await bot.sendMessage(chatId, "üíº Trade feature coming soon!");
    return;
  }
  if (text === "üí≥ Set Wallet") {
    await handleSetWallet(chatId, userId);
    return;
  }
  if (text === "üë• Referral") {
    await handleReferral(chatId, userId);
    return;
  }
  if (text === "üí∞ Balance") {
    await handleBalance(chatId, userId);
    return;
  }
  if (text === "‚ÑπÔ∏è About Us") {
    await bot.sendMessage(chatId, "About Us", {
      reply_markup: {
        inline_keyboard: [[{ text: "Open About Us", url: ABOUT_US_URL }]]
      }
    });
    return;
  }
  if (text === "üí¨ Support") {
    const supportLink = SUPPORT_URL.startsWith("http") ? SUPPORT_URL : `https://t.me/${SUPPORT_URL.replace(/^@/, '')}`;
    await bot.sendMessage(chatId, "Support", {
      reply_markup: {
        inline_keyboard: [[{ text: "Open Support", url: supportLink }]]
      }
    });
    return;
  }
  if (text === "üìä Stats") {
    await handleStats(chatId);
    return;
  }

  if (awaitingWallet[userId]) {
    const addr = text.trim();
    const user = ensureUser(userId);
    user.wallet = addr;
    delete awaitingWallet[userId];
    await bot.sendMessage(chatId, `‚úÖ Wallet saved: ${addr}`);
    return;
  }

  if (pendingTasks[userId]) {
    if (msg.photo) {
      const photo = msg.photo[msg.photo.length - 1];
      pendingTasks[userId].files.push(photo.file_id);
      await bot.sendMessage(chatId, "‚úÖ Image received. Send more or press Done.");
      return;
    }
    if (text && text !== "Done") {
      pendingTasks[userId].text += "\n" + text;
      await bot.sendMessage(chatId, "‚úÖ Description saved. Send more or press Done.");
      return;
    }
  }
});

bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const userId = query.from.id;
  const data = query.data;

  if (data === "verify_now") {
    const missing = [];
    for (const ch of CHANNELS_TO_VERIFY) {
      try {
        const member = await bot.getChatMember(ch, userId);
        if (!['member', 'administrator', 'creator'].includes(member.status)) {
          missing.push(ch);
        }
      } catch (e) {
        missing.push(ch);
      }
    }

    if (missing.length > 0) {
      await bot.answerCallbackQuery(query.id, {
        text: "Please join all required Telegram channels and try again.",
        show_alert: true
      });
      return;
    }

    const user = ensureUser(userId);
    if (!user.verified) {
      user.verified = true;
      if (user.referredBy) {
        const ref = ensureUser(user.referredBy);
        const reward = botSettings.referralReward;
        ref.balance = Number(ref.balance || 0) + reward;
        ref.referrals = ref.referrals || [];
        ref.referrals.push(userId);
        try {
          await bot.sendMessage(user.referredBy, `üéâ You earned ${reward} for referring a verified user!`);
        } catch (e) {}
      }
    }

    await bot.answerCallbackQuery(query.id, { text: "Verification successful!" });
    await showMenu(chatId);
    return;
  }

  if (data === "start_submit_task") {
    pendingTasks[userId] = { files: [], text: "" };
    await bot.sendMessage(chatId, "üì§ Send proof images and description. Press Done when finished.", {
      reply_markup: {
        inline_keyboard: [[{ text: "Done", callback_data: "finish_task_submit" }]]
      }
    });
    await bot.answerCallbackQuery(query.id);
    return;
  }

  if (data === "finish_task_submit") {
    await finishTaskSubmit(userId, chatId);
    await bot.answerCallbackQuery(query.id, { text: "Submission sent for review." });
    return;
  }

  if (data.startsWith("task_confirm:")) {
    const targetId = data.split(":")[1];
    await handleAdminTaskConfirm(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Task approved." });
    return;
  }

  if (data.startsWith("task_reject:")) {
    const targetId = data.split(":")[1];
    await handleAdminTaskReject(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Task rejected." });
    return;
  }

  if (data.startsWith("withdraw_confirm:")) {
    const parts = data.split(":");
    const targetId = parts[1];
    const amount = Number(parts[2]);
    await handleAdminWithdrawConfirm(userId, targetId, amount, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Withdrawal approved." });
    return;
  }

  if (data.startsWith("withdraw_reject:")) {
    const parts = data.split(":");
    const targetId = parts[1];
    await handleAdminWithdrawReject(userId, targetId, query.message.chat.id);
    await bot.answerCallbackQuery(query.id, { text: "Withdrawal rejected." });
    return;
  }
});

async function showMenu(chatId) {
  const keyboard = {
    keyboard: [
      ["üéØ Task", "üéÅ Bonus"],
      ["üíº Trade", "üí≥ Set Wallet"],
      ["üë• Referral", "üí∞ Balance"],
      ["‚ÑπÔ∏è About Us", "üí¨ Support", "üìä Stats"]
    ],
    resize_keyboard: true
  };
  await bot.sendMessage(chatId, "üè† Main Menu ‚Äî Choose an option:", { reply_markup: keyboard });
}

async function handleTask(chatId) {
  const text = "üéØ Tasks:\n1) Share our channel\n2) Upload proof (images)\n\nPress Submit Proof to start.";
  const inlineKeyboard = {
    inline_keyboard: [[{ text: "Submit Proof", callback_data: "start_submit_task" }]]
  };
  await bot.sendMessage(chatId, text, { reply_markup: inlineKeyboard });
}

async function handleBonus(chatId, userId) {
  const user = ensureUser(userId);
  const bonus = botSettings.bonusAmount;
  user.balance = Number(user.balance || 0) + bonus;
  await bot.sendMessage(chatId, `üéÅ Bonus added: ${bonus}\nCurrent balance: ${user.balance}`);
}

async function handleSetWallet(chatId, userId) {
  await bot.sendMessage(chatId, "üîê Please send your wallet address now.");
  awaitingWallet[userId] = true;
}

async function handleReferral(chatId, userId) {
  const user = ensureUser(userId);
  const link = `https://t.me/${BOT_USERNAME}?start=${userId}`;
  const earned = (user.referrals ? user.referrals.length * botSettings.referralReward : 0);
  await bot.sendMessage(chatId, `üë• Your referral link:\n${link}\nReferrals: ${user.referrals ? user.referrals.length : 0}\nEarned: ${earned}`);
}

async function handleBalance(chatId, userId) {
  const user = ensureUser(userId);
  await bot.sendMessage(chatId, `${CURRENCY_SYMBOL} Balance: ${user.balance || 0}\nWallet: ${user.wallet || "(not set)"}`);
}

async function handleStats(chatId) {
  const totalUsers = Object.keys(usersDB).length;
  const verifiedUsers = Object.values(usersDB).filter(u => u.verified).length;
  const totalTasks = botSettings.tasksSubmitted;
  
  await bot.sendMessage(chatId, `üìä Bot Statistics:\n\nTotal Users: ${totalUsers}\nVerified Users: ${verifiedUsers}\nTasks Submitted: ${totalTasks}`);
}

async function finishTaskSubmit(userId, chatId) {
  const pending = pendingTasks[userId];
  if (!pending) {
    await bot.sendMessage(chatId, "No pending submission. Use üéØ Task to start.");
    return;
  }

  const msg = `üìù New Task Submission\nUser ID: ${userId}\n\nDescription:\n${pending.text || "(no description)"}`;
  const inlineKeyboard = {
    inline_keyboard: [[
      { text: "‚úÖ Confirm", callback_data: `task_confirm:${userId}` },
      { text: "‚ùå Reject", callback_data: `task_reject:${userId}` }
    ]]
  };

  await bot.sendMessage(TASK_REVIEW_CHANNEL, msg);
  
  if (pending.files && pending.files.length > 0) {
    for (const fileId of pending.files) {
      try {
        await bot.sendPhoto(TASK_REVIEW_CHANNEL, fileId);
      } catch (e) {}
    }
  }

  await bot.sendMessage(ADMIN_GROUP_ID, msg);
  
  if (pending.files && pending.files.length > 0) {
    for (const fileId of pending.files) {
      try {
        await bot.sendPhoto(ADMIN_GROUP_ID, fileId);
      } catch (e) {}
    }
  }

  await bot.sendMessage(ADMIN_GROUP_ID, "Admin review required:", { reply_markup: inlineKeyboard });

  botSettings.tasksSubmitted++;
  await bot.sendMessage(chatId, "‚úÖ Your submission has been sent for review.");
  delete pendingTasks[userId];
}

async function handleAdminTaskConfirm(adminId, targetId, chatId) {
  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è This must be done in the admin group.");
    return;
  }
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  const reward = botSettings.taskReward;
  const target = ensureUser(targetId);
  target.balance = Number(target.balance || 0) + reward;

  try {
    await bot.sendMessage(targetId, `‚úÖ Your task has been approved. Reward: ${reward}`);
  } catch (e) {}

  await bot.sendMessage(ADMIN_GROUP_ID, `‚úÖ Task approved for user: ${targetId}`);
  await logAdmin(`Task approved for user: ${targetId} by admin: ${adminId}`);
}

async function handleAdminTaskReject(adminId, targetId, chatId) {
  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è This must be done in the admin group.");
    return;
  }
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  try {
    await bot.sendMessage(targetId, "‚ùå Your task submission was rejected by admin.");
  } catch (e) {}

  await bot.sendMessage(ADMIN_GROUP_ID, `‚ùå Task rejected for user: ${targetId}`);
  await logAdmin(`Task rejected for user: ${targetId} by admin: ${adminId}`);
}

bot.onText(/\/withdraw/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!botSettings.withdrawalOpen) {
    await bot.sendMessage(chatId, "‚ùå Withdrawals are currently closed.");
    return;
  }

  await bot.sendMessage(chatId, "üí∏ To request withdrawal send: /requestwithdraw <amount>");
});

bot.onText(/\/requestwithdraw (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = Number(match[1]);
  const user = ensureUser(userId);

  if (!botSettings.withdrawalOpen) {
    await bot.sendMessage(chatId, "‚ùå Withdrawals are closed.");
    return;
  }

  if (isNaN(amount) || amount <= 0 || amount > Number(user.balance || 0)) {
    await bot.sendMessage(chatId, "‚ùå Invalid amount or insufficient balance.");
    return;
  }

  const inlineKeyboard = {
    inline_keyboard: [[
      { text: "‚úÖ Approve", callback_data: `withdraw_confirm:${userId}:${amount}` },
      { text: "‚ùå Reject", callback_data: `withdraw_reject:${userId}:${amount}` }
    ]]
  };

  await bot.sendMessage(WITHDRAW_REVIEW_CHANNEL, 
    `üí∏ Withdrawal request\nUser: ${userId}\nAmount: ${amount}\nWallet: ${user.wallet || "(not set)"}`
  );

  await bot.sendMessage(ADMIN_GROUP_ID,
    `üí∏ Withdrawal request\nUser: ${userId}\nAmount: ${amount}\nWallet: ${user.wallet || "(not set)"}`,
    { reply_markup: inlineKeyboard }
  );

  await bot.sendMessage(chatId, "‚úÖ Your withdrawal request has been sent for review.");
});

async function handleAdminWithdrawConfirm(adminId, targetId, amount, chatId) {
  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è This must be done in the admin group.");
    return;
  }
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  const user = ensureUser(targetId);
  if (Number(user.balance || 0) < amount) {
    await bot.sendMessage(ADMIN_GROUP_ID, "Insufficient funds or user not found.");
    return;
  }

  user.balance = Number(user.balance) - amount;

  try {
    await bot.sendMessage(targetId, `‚úÖ Your withdrawal of ${amount} has been approved by admin.`);
  } catch (e) {}

  await bot.sendMessage(ADMIN_GROUP_ID, `‚úÖ Withdrawal approved for user: ${targetId} amount: ${amount}`);
  await logAdmin(`Withdrawal approved for user: ${targetId} amount: ${amount} by admin: ${adminId}`);
}

async function handleAdminWithdrawReject(adminId, targetId, chatId) {
  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è This must be done in the admin group.");
    return;
  }
  if (!isAdminId(adminId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  try {
    await bot.sendMessage(targetId, "‚ùå Your withdrawal request was rejected by admin.");
  } catch (e) {}

  await bot.sendMessage(ADMIN_GROUP_ID, `‚ùå Withdrawal rejected for user: ${targetId}`);
  await logAdmin(`Withdrawal rejected for user: ${targetId} by admin: ${adminId}`);
}

bot.onText(/\/addbalance (\d+) (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetId = match[1];
  const amount = Number(match[2]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run this inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  const user = ensureUser(targetId);
  user.balance = Number(user.balance || 0) + amount;
  await bot.sendMessage(ADMIN_GROUP_ID, `‚úÖ Added ${amount} to user ${targetId}`);
  await logAdmin(`addbalance ${targetId} ${amount} by ${userId}`);
});

bot.onText(/\/deductbalance (\d+) (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const targetId = match[1];
  const amount = Number(match[2]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run this inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  const user = ensureUser(targetId);
  user.balance = Number(user.balance || 0) - amount;
  if (user.balance < 0) user.balance = 0;
  await bot.sendMessage(ADMIN_GROUP_ID, `‚úÖ Deducted ${amount} from user ${targetId}`);
  await logAdmin(`deductbalance ${targetId} ${amount} by ${userId}`);
});

bot.onText(/\/openwithdrawal/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  botSettings.withdrawalOpen = true;
  await bot.sendMessage(ADMIN_GROUP_ID, "üîì Withdrawals are now OPEN.");
  await logAdmin(`openwithdrawal by ${userId}`);
});

bot.onText(/\/closewithdrawal/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  botSettings.withdrawalOpen = false;
  await bot.sendMessage(ADMIN_GROUP_ID, "üîí Withdrawals are now CLOSED.");
  await logAdmin(`closewithdrawal by ${userId}`);
});

bot.onText(/\/broadcast (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const message = match[1];

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  let count = 0;
  for (const uid in usersDB) {
    try {
      await bot.sendMessage(usersDB[uid].id, message);
      count++;
    } catch (e) {}
  }

  await bot.sendMessage(ADMIN_GROUP_ID, `üì£ Broadcast sent to ${count} users.`);
  await logAdmin(`broadcast by ${userId} message: ${message}`);
});

bot.onText(/\/addtask (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const task = match[1];

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  await bot.sendMessage(TASK_REVIEW_CHANNEL, `üéØ New Task: ${task}`);
  await bot.sendMessage(ADMIN_GROUP_ID, "‚úÖ Task posted to review channel.");
  await logAdmin(`addtask by ${userId} task: ${task}`);
});

bot.onText(/\/updatereward (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = Number(match[1]);

  if (chatId !== ADMIN_GROUP_ID) {
    await sendEphemeralWarning(chatId, "‚ö†Ô∏è Run inside admin group only.");
    return;
  }
  if (!isAdminId(userId)) {
    await sendEphemeralWarning(chatId, "‚õî You are not authorized!");
    return;
  }

  botSettings.taskReward = amount;
  await bot.sendMessage(ADMIN_GROUP_ID, `‚úÖ Task reward updated to ${amount}`);
  await logAdmin(`updatereward ${amount} by ${userId}`);
});

bot.onText(/\/menu/, async (msg) => {
  await showMenu(msg.chat.id);
});

console.log('Bot is running...');
